###  能说下 myisam 和 innodb 的区别吗？

myisam 引擎是 5.1 版本之前的默认引擎，支持全文检索、压缩、空间函数等，但是不支持事务和行级锁，所以一般用于有大量查询少量插入的场景来使用，而且 myisam 不支持外键，并且索引和数据是分开存储的。

innodb 是基于聚簇索引建立的，和 myisam 相反它支持事务、外键，并且通过 MVCC 来支持高并发，索引和数据存储在一起。

### 2. 索引按照数据结构来说主要包含 B + 树和 Hash 索引。

假设我们有张表，结构如下：

```
create table user(
  id int(11) not null,
  age int(11) not null,
  primary key(id),
  key(age)
);Copy to clipboardErrorCopied
```

B + 树是左小右大的顺序存储结构，节点只包含 id 索引列，而叶子节点包含索引列和数据，这种数据和索引在一起存储的索引方式叫做聚簇索引，一张表只能有一个聚簇索引。假设没有定义主键，InnoDB 会选择一个唯一的非空索引代替，如果没有的话则会隐式定义一个主键作为聚簇索引。

![img](https://pic4.zhimg.com/v2-bafac0872e81d3c786ff0f8152b7e98b_r.jpg?source=1940ef5c)

这是主键聚簇索引存储的结构，那么非聚簇索引的结构是什么样子呢？非聚簇索引 (二级索引) 保存的是主键 id 值，这一点和 myisam 保存的是数据地址是不同的。

![img](https://pic3.zhimg.com/v2-b36c1bd75165e50522a5e8b0caf0f9c9_r.jpg?source=1940ef5c)

最终，我们一张图看看 InnoDB 和 Myisam 聚簇和非聚簇索引的区别

![img](https://pic2.zhimg.com/v2-197c55fed2cb8d8e3dae118c7b75d3b2_r.jpg?source=1940ef5c)

### 你能说下事务的基本特性和隔离级别吗？

事务基本特性 ACID 分别是：

**原子性**指的是一个事务中的操作要么全部成功，要么全部失败。

**一致性**指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如 A 转账给 B100 块钱，假设中间 sql 执行过程中系统崩溃 A 也不会损失 100 块，因为事务没有提交，修改也就不会保存到数据库。

**隔离性**指的是一个事务的修改在最终提交前，对其他事务是不可见的。

**持久性**指的是一旦事务提交，所做的修改就会永久保存到数据库中。

而隔离性有 4 个隔离级别，分别是：

**read uncommit** 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。

用户本来应该读取到 id=1 的用户 age 应该是 10，结果读取到了其他事务还没有提交的事务，结果读取结果 age=20，这就是脏读。

![img](https://pic1.zhimg.com/v2-593fbcf68e09e8864d7205028f47b681_r.jpg?source=1940ef5c)

**read commit** 读已提交，两次读取结果不一致，叫做不可重复读。

不可重复读解决了脏读的问题，他只会读取已经提交的事务。

用户开启事务读取 id=1 用户，查询到 age=10，再次读取发现结果 = 20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读。

![img](https://pic1.zhimg.com/v2-709b3f048ebc3ffc32da906c3e8965d3_r.jpg?source=1940ef5c)

**repeatable read** 可重复复读，这是 mysql 的默认级别，就是每次读取结果都一样，但是有可能产生幻读。

**serializable** 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。

###  ACID 靠什么保证的呢？

A 原子性由 undo log 日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 sql

C 一致性一般由代码层面来保证

I 隔离性由 MVCC 来保证

D 持久性由内存 + redo log 来保证，mysql 修改数据同时在内存和 redo log 记录这次操作，事务提交的时候通过 redo log 刷盘，宕机的时候可以从 redo log 恢复

>InnoDB redo log 写盘，InnoDB 事务进入 prepare 状态。
>如果前面 prepare 成功，binlog 写盘，再继续将事务日志持久化到 binlog，如果持久化成功，那么InnoDB 事务则进入 commit 状态(在 redo log 里面写一个 commit 记录)

### 怎样分库分表？

**水平切分**

水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。

当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。

![](https://picture.lingzero.cn/202207211216634.png)

**垂直切分**

![](https://picture.lingzero.cn/202207211216132.png)

垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。

### 分表后，怎样保证ID唯一？

- 使用全局唯一 ID: GUID
- 为每个分片指定一个 ID 范围（设置步长）
- 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)